<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Draw with music!</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.8.39/build/Tone.min.js"></script>
  <style>
@media (max-width: 900px), (max-width: 1024px) and (orientation: portrait), (max-width: 1024px) and (orientation: landscape) {
  html, body, canvas, #aOverlay {
    width: 100vw !important;
    height: 100vh !important;
    max-width: 100vw !important;
    max-height: 100vh !important;
    font-family: "Comic Sans MS", "Comic Sans", cursive, sans-serif !important;
  }
  #title, #prompt {
    font-family: "Comic Sans MS", "Comic Sans", cursive, sans-serif !important;
  }
  #letterGrid, .letter-item {
    font-family: "Comic Sans MS", "Comic Sans", cursive, sans-serif !important;
  }
}
/* Overlay cross button for stencil mode */
#stencilCloseBtn {
  position: fixed;
  top: clamp(10px, 2vh, 20px);
  right: clamp(10px, 2vw, 20px);
  width: 44px;
  height: 44px;
  border-radius: 50%;
  background: linear-gradient(45deg, #000 0%, #000 49%, #fff 49%, #fff 51%, #000 51%);
  border: 3px solid #fff;
  color: white;
  font-size: 2rem;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  display: none;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  z-index: 100;
}

#stencilCloseBtn:before {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 24px;
  height: 4px;
  background: white;
  border-radius: 2px;
  transform: translate(-50%, -50%) rotate(45deg);
}
#stencilCloseBtn:after {
  content: '';
  position: absolute;
  top: 50%;
  left: 50%;
  width: 24px;
  height: 4px;
  background: white;
  border-radius: 2px;
  transform: translate(-50%, -50%) rotate(-45deg);
}

#stencilCloseBtn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
}
    @font-face {
      font-family: "CLT Apfel Grotezk";
      src: url("CLT Apfel Grotezk/web/ApfelGrotezk-Regular.woff2") format("woff2");
    }
    @font-face {
      font-family: "Comic Sans MS";
      src: local("Comic Sans MS"), local("Comic Sans"), url("https://fonts.cdnfonts.com/s/14617/Comic_Sans_MS.woff") format("woff");
      font-style: normal;
      font-weight: normal;
    }

    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100vh;
      width: 100vw;
      font-family: "CLT Apfel Grotezk", sans-serif;
      background: url('white-wall.jpg') no-repeat center center fixed;
      background-size: cover;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none;
    }

#title {
  position: fixed;
  top: 0;
  width: 100%;
  text-align: center;
  background: white;
  font-size: clamp(1rem, 2vw, 2.5rem);
  font-weight: bold;
  padding: clamp(0.5rem, 0.9rem, 1.2rem);
  z-index: 10;
  animation: floatTitle 4s ease-in-out infinite;
  transition: transform 0.3s ease;
}

@keyframes floatTitle {
  0%, 100% {
    transform: translateY(7px);
  }
  50% {
    transform: translateY(-7px);
  }
}

#prompt {
  position: fixed;
  top: 90%;
  left: 50%;
  transform: translate(-50%, -50%);
  background: rgba(255,255,255,0.95);
  padding: clamp(0.8rem, 1rem, 1.5rem) clamp(1.2rem, 2rem, 2.5rem);
  border-radius: 20px;
  font-size: clamp(0.8rem, 1vw, 1.2rem);
  font-weight: bold;
  z-index: 20;
  animation: fadeOut 2s 2s forwards;
  text-align: center;
  max-width: 90vw;
  box-sizing: border-box;
}

@keyframes fadeOut {
  to {
    opacity: 0;
    visibility: hidden;
  }
}

canvas {
  display: block;
  position: absolute;
  top: 0;
  left: 0;
  z-index: 1;
  width: 100vw;
  height: 100vh;
  max-width: 100vw;
  max-height: 100vh;
  touch-action: none;
}

#aOverlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  z-index: 2;
  pointer-events: none;
  display: none;
}

/* Circular dropdown styles */
#circularDropdown {
  position: fixed;
  top: clamp(80px, 15vh, 120px);
  left: clamp(20px, 4vw, 40px);
  z-index: 15;
}

#dropdownToggle {
  width: clamp(60px, 10vw, 80px);
  height: clamp(60px, 10vw, 80px);
  border-radius: 50%;
  background: linear-gradient(135deg, #ff179e, #9855fe, #45a0fc);
  border: none;
  color: white;
  font-size: clamp(1.2rem, 2vw, 1.8rem);
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
}

#dropdownToggle:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
}

#dropdownToggle.selected {
  box-shadow: 0 0 20px #fff, 0 0 30px #fff, 0 0 40px #fff;
}

#dropdownMenu {
  position: absolute;
  top: calc(100% + 20px);
  left: 0;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: 15px;
  align-items: center;
}

#dropdownMenu.open {
  opacity: 1;
  visibility: visible;
  pointer-events: all;
}

.dropdown-row {
  display: flex;
  gap: 15px;
  align-items: center;
}

.dropdown-item {
  position: relative;
  width: clamp(50px, 8vw, 65px);
  height: clamp(50px, 8vw, 65px);
  border-radius: 50%;
  border: none;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 2px 8px rgba(0,0,0,0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(0.7rem, 1.2vw, 1rem);
  color: white;
  font-family: "CLT Apfel Grotezk", sans-serif;
  font-weight: bold;
  transform: none;
}

.dropdown-item:hover {
  transform: scale(1.1);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.dropdown-item.selected {
  box-shadow: 0 0 15px #fff, 0 0 25px #fff, 0 0 35px #fff;
}

#brushSizeContainer {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  padding: 12px;
  background: rgba(255, 192, 203, 0.2);
  border-radius: 15px;
  border: 2px solid rgb(255, 0, 221);
  backdrop-filter: blur(10px);
  transform: none;
}

/* A Mode Cancel Button */
#aCancelBtn {
  position: fixed;
  top: clamp(20px, 4vh, 40px);
  right: clamp(20px, 4vw, 40px);
  width: clamp(50px, 8vw, 70px);
  height: clamp(50px, 8vw, 70px);
  border-radius: 50%;
  background: linear-gradient(45deg, #000 0%, #000 49%, #fff 49%, #fff 51%, #000 51%);
  border: 3px solid #666;
  color: white;
  font-size: clamp(1.2rem, 2vw, 1.8rem);
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  display: none;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  z-index: 20;
}

#aCancelBtn:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 20px rgba(0,0,0,0.4);
}

/* Letter Grid Modal */
#letterGridModal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background: rgba(0, 0, 0, 0.8);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 25;
}

#letterGrid {
  background: white;
  border-radius: 20px;
  padding: 20px;
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 10px;
}

.letter-item {
  width: clamp(60px, 8vw, 80px);
  height: clamp(60px, 8vw, 80px);
  border: 2px solid #ccc;
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: clamp(1rem, 2vw, 1.5rem);
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s ease;
  background: white;
  color: #333;
}

.letter-item:hover {
  transform: scale(1.1);
  border-color: #ff179e;
  background: #f0f0f0;
}

#closeLetterGrid {
  position: absolute;
  top: 10px;
  right: 10px;
  width: 40px;
  height: 40px;
  border: none;
  background: #ff179e;
  color: white;
  border-radius: 50%;
  font-size: 1.5rem;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
}

/* Color button styles */
.pink { background-color: rgb(255, 0, 221); }
.purple { background-color: rgb(92, 0, 157); }
.yellow { background-color: rgb(255, 187, 0); }
.orange { background-color: rgb(255, 77, 0); }
.blue { background-color: rgb(125, 244, 255); }

.gradient { 
  background: radial-gradient(circle, 
    rgb(255, 0, 221) 0%, 
    rgb(92, 0, 157) 20%, 
    rgb(255, 187, 0) 40%, 
    rgb(255, 77, 0) 60%, 
    rgb(125, 244, 255) 80%,
    rgb(255, 0, 221) 100%);
  position: relative;
  overflow: hidden;
}

.gradient::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle, 
    rgb(255, 0, 221) 0%, 
    rgb(92, 0, 157) 20%, 
    rgb(255, 187, 0) 40%, 
    rgb(255, 77, 0) 60%, 
    rgb(125, 244, 255) 80%,
    rgb(255, 0, 221) 100%);
  animation: gradientShift 3s ease-in-out infinite;
  border-radius: 50%;
}

@keyframes gradientShift {
  0%, 100% { transform: rotate(0deg) scale(1); }
  50% { transform: rotate(180deg) scale(1.1); }
}

.eraser { 
  background-color: #f0f0f0; 
  color: #333;
  border: 3px solid #999;
}

.a-button {
  background-color: #000;
  color: white;
  font-size: clamp(1.2rem, 2vw, 1.8rem);
}

#brushSizeSlider {
  -webkit-appearance: none;
  appearance: none;
  width: 80px;
  height: 6px;
  border-radius: 3px;
  background: linear-gradient(to right, rgb(255, 0, 221), rgb(255, 100, 200));
  outline: none;
  opacity: 0.9;
  transition: opacity 0.2s;
}

#brushSizeSlider:hover {
  opacity: 1;
}

#brushSizeSlider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: rgb(255, 0, 221);
  cursor: pointer;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  transition: transform 0.2s ease;
}

#brushSizeSlider::-webkit-slider-thumb:hover {
  transform: scale(1.1);
}

#brushSizeSlider::-moz-range-thumb {
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: rgb(255, 0, 221);
  cursor: pointer;
  border: none;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  transition: transform 0.2s ease;
}

#brushSizeSlider::-moz-range-thumb:hover {
  transform: scale(1.1);
}

#brushSizeLabel {
  font-size: clamp(0.6rem, 1vw, 1rem);
  font-weight: bold;
  color: rgb(255, 0, 221);
  text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
}

#mainResetBtn {
  position: fixed;
  bottom: clamp(10px, 3vh, 25px);
  right: clamp(10px, 3vw, 25px);
  background: linear-gradient(90deg, #ff179e, #9855fe, #45a0fc);
  color: rgb(0, 0, 0);
  z-index: 10;
  padding: clamp(0.4rem, 0.6rem, 0.8rem) clamp(0.6rem, 1rem, 1.2rem);
  font-weight: bold;
  border: none;
  border-radius: 15px;
  font-size: clamp(0.7rem, 1rem, 1.1rem);
  cursor: pointer;
}

#mainResetBtn:hover {
  transform: scale(1.05);
  background: linear-gradient(90deg, #c1ff3c, #55fef8,#45a0fc);
  color: rgb(255, 255, 255);
}

#cameraBtn {
  position: fixed;
  bottom: clamp(10px, 3vh, 25px);
  left: clamp(10px, 3vw, 25px);
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  z-index: 10;
  padding: clamp(0.4rem, 0.6rem, 0.8rem) clamp(0.6rem, 1rem, 1.2rem);
  font-weight: bold;
  border: none;
  border-radius: 15px;
  font-size: clamp(0.7rem, 1rem, 1.1rem);
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
}

#cameraBtn:hover {
  transform: scale(1.05);
  background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
}

.hidden {
  display: none;
}

/* Responsive positioning for dropdown items */
@media (max-width: 900px) {
  #circularDropdown {
    top: clamp(60px, 10vh, 90px);
    left: clamp(10px, 2vw, 20px);
  }
  #dropdownToggle {
    width: 48px;
    height: 48px;
    font-size: 1rem;
  }
  .dropdown-item {
    width: 38px;
    height: 38px;
    font-size: 0.8rem;
  }
  .dropdown-row {
    gap: 8px;
  }
  #brushSizeContainer {
    padding: 6px;
  }
  #brushSizeSlider {
    width: 48px;
  }
  #aCancelBtn {
    width: 38px;
    height: 38px;
    font-size: 0.9rem;
    top: clamp(10px, 2vh, 20px);
    right: clamp(10px, 2vw, 20px);
  }
  #letterGrid {
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
    padding: 10px;
  }
  .letter-item {
    width: clamp(38px, 10vw, 48px);
    height: clamp(38px, 10vw, 48px);
    font-size: clamp(0.7rem, 2vw, 1rem);
  }
  #mainResetBtn, #cameraBtn {
    font-size: 0.8rem;
    padding: 0.4rem 0.7rem;
    border-radius: 12px;
  }
  #title {
    font-size: clamp(0.8rem, 1.5vw, 1.2rem);
    padding: clamp(0.3rem, 0.6rem, 0.8rem);
  }
  #prompt {
    top: 88%;
    font-size: clamp(0.7rem, 1vw, 1rem);
    padding: 0.7rem 1.2rem;
    border-radius: 14px;
  }
}

@media (max-width: 600px) {
  #circularDropdown {
    top: clamp(40px, 7vh, 60px);
    left: clamp(6px, 1vw, 12px);
  }
  #dropdownToggle {
    width: 38px;
    height: 38px;
    font-size: 0.9rem;
  }
  .dropdown-item {
    width: 30px;
    height: 30px;
    font-size: 0.7rem;
  }
  .dropdown-row {
    gap: 5px;
  }
  #brushSizeContainer {
    padding: 4px;
  }
  #brushSizeSlider {
    width: 32px;
  }
  #aCancelBtn {
    width: 30px;
    height: 30px;
    font-size: 0.8rem;
    top: clamp(6px, 1vh, 12px);
    right: clamp(6px, 1vw, 12px);
  }
  #letterGrid {
    grid-template-columns: repeat(2, 1fr);
    gap: 4px;
    padding: 6px;
  }
  .letter-item {
    width: clamp(28px, 8vw, 36px);
    height: clamp(28px, 8vw, 36px);
    font-size: clamp(0.6rem, 2vw, 0.9rem);
  }
  #mainResetBtn, #cameraBtn {
    font-size: 0.7rem;
    padding: 0.3rem 0.5rem;
    border-radius: 10px;
  }
  #title {
    font-size: clamp(0.7rem, 1vw, 1rem);
    padding: clamp(0.2rem, 0.4rem, 0.6rem);
  }
  #prompt {
    top: 86%;
    font-size: clamp(0.6rem, 0.8vw, 0.9rem);
    padding: 0.5rem 0.8rem;
    border-radius: 10px;
  }
}

@media (orientation: landscape) and (max-height: 600px) {
  #circularDropdown {
    top: clamp(30px, 6vh, 40px);
    left: clamp(6px, 1vw, 12px);
  }
  #title {
    font-size: clamp(0.7rem, 1vw, 1rem);
    padding: clamp(0.2rem, 0.4rem, 0.6rem);
  }
  #prompt {
    top: 80%;
    font-size: clamp(0.6rem, 0.8vw, 0.9rem);
    padding: 0.4rem 0.7rem;
    border-radius: 8px;
  }
  .dropdown-row {
    gap: 4px;
  }
  .dropdown-item {
    width: 24px;
    height: 24px;
    font-size: 0.6rem;
  }
  #dropdownToggle {
    width: 24px;
    height: 24px;
    font-size: 0.7rem;
  }
  #aCancelBtn {
    width: 24px;
    height: 24px;
    font-size: 0.7rem;
  }
}
  </style>
</head>
<body>

  <div id="prompt">Paint, Gradient, Erase, A/a Mode, Scrape.</div>

  <div id="title">Draw, Hide, and Scratch to reveal!</div>
  
  <!-- Circular Dropdown -->
  <div id="circularDropdown">
    <button id="dropdownToggle">â˜°</button>
    <div id="dropdownMenu">
      <!-- Colors row -->
      <div class="dropdown-row">
        <button class="dropdown-item pink" data-color="rgb(255, 0, 221)"></button>
        <button class="dropdown-item purple" data-color="rgb(92, 0, 157)"></button>
        <button class="dropdown-item yellow" data-color="rgb(255, 187, 0)"></button>
        <button class="dropdown-item orange" data-color="rgb(255, 77, 0)"></button>
        <button class="dropdown-item blue" data-color="rgb(125, 244, 255)"></button>
      </div>
      
      <!-- Tools row -->
      <div class="dropdown-row">
        <button class="dropdown-item gradient" id="gradientBtn">ðŸŒˆ</button>
        <button class="dropdown-item eraser" id="eraserBtn">âšª</button>
        
        <!-- Brush size container positioned to the right -->
        <div id="brushSizeContainer">
          <input type="range" id="brushSizeSlider" min="5" max="50" value="30" step="1">
          <span id="brushSizeLabel">30px</span>
        </div>
      </div>
    </div>
    
    <!-- A/a button positioned to the right of dropdown toggle -->
    <button class="dropdown-item a-button" id="aBtn" style="position: absolute; top: 0; left: calc(100% + 20px);">A/a</button>
  </div>

  <!-- Letter Grid Modal -->
  <div id="letterGridModal">
    <div id="letterGrid">
      <button id="closeLetterGrid">âœ•</button>
    </div>
  </div>

  <!-- A Mode Cancel Button -->
  <button id="aCancelBtn">âœ•</button>

  <button id="mainResetBtn">Reset</button>
  <button id="cameraBtn">ðŸ“· Save</button>
  <canvas id="colorCanvas"></canvas>
  <!-- Stencil overlay canvas (same as aOverlay, reused for stencil mode) -->
  <canvas id="aOverlay"></canvas>
  <button id="stencilCloseBtn">âœ•</button>

  <script>
    // --- Digital Stencil Feature ---
    let isStencilMode = false;
    const stencilCloseBtn = document.getElementById('stencilCloseBtn');

    // Show stencil overlay with transparent letter/digit
    function showStencilOverlay(char) {
      isStencilMode = true;
      selectedLetter = char;
      document.getElementById('letterGridModal').style.display = 'none';
      drawStencilOverlay(char);
      stencilCloseBtn.style.display = 'flex';
      aOverlay.style.display = 'block';
      // Keep dropdown and UI visible
      document.getElementById('circularDropdown').style.zIndex = 40;
      document.getElementById('mainResetBtn').style.zIndex = 40;
      document.getElementById('cameraBtn').style.zIndex = 40;
      document.getElementById('title').style.zIndex = 40;
      document.getElementById('prompt').style.zIndex = 40;
    }

    // Draw stencil overlay: black everywhere, transparent where char is
    function drawStencilOverlay(char) {
      aOverlay.width = window.innerWidth;
      aOverlay.height = window.innerHeight;
      aCtx.clearRect(0, 0, aOverlay.width, aOverlay.height);
      // Fill with black
      aCtx.globalAlpha = 1.0;
      aCtx.fillStyle = 'black';
      aCtx.fillRect(0, 0, aOverlay.width, aOverlay.height);
      // Draw transparent letter/digit
      aCtx.save();
      aCtx.globalCompositeOperation = 'destination-out';
      // Calculate font size and position
      let fontSize = Math.min(aOverlay.width, aOverlay.height) * 0.6;
      if (char.length > 1) fontSize *= 0.7;
      aCtx.font = `bold ${fontSize}px "Comic Sans MS", "Comic Sans", cursive, sans-serif`;
      aCtx.textAlign = 'center';
      aCtx.textBaseline = 'middle';
      aCtx.fillText(char, aOverlay.width/2, aOverlay.height/2);
      aCtx.restore();
      aCtx.globalCompositeOperation = 'source-over';
    }

    // Remove stencil overlay
    function exitStencilMode() {
      isStencilMode = false;
      aOverlay.style.display = 'none';
      stencilCloseBtn.style.display = 'none';
      // Restore z-indexes
      document.getElementById('circularDropdown').style.zIndex = 15;
      document.getElementById('mainResetBtn').style.zIndex = 10;
      document.getElementById('cameraBtn').style.zIndex = 10;
      document.getElementById('title').style.zIndex = 10;
      document.getElementById('prompt').style.zIndex = 20;
    }

    // When resizing, redraw overlay if stencil mode is active
    const origResizeCanvasDimensions = resizeCanvasDimensions;
    resizeCanvasDimensions = function() {
      colorCanvas.width = aOverlay.width = window.innerWidth;
      colorCanvas.height = aOverlay.height = window.innerHeight;
      if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        ctx.drawImage(backgroundImage, 0, 0, colorCanvas.width, colorCanvas.height);
      } else {
        createWhiteBackground();
      }
      // Redraw A overlay if in A mode
      if (isAMode && aImage) {
        drawAOverlay();
      }
      // Redraw stencil overlay if active
      if (isStencilMode && selectedLetter) {
        drawStencilOverlay(selectedLetter);
      }
    }

    // Stencil close button event
    stencilCloseBtn.addEventListener('click', function(e) {
      e.preventDefault();
      exitStencilMode();
    });
    stencilCloseBtn.addEventListener('touchend', function(e) {
      e.preventDefault();
      exitStencilMode();
    });
    const colorCanvas = document.getElementById('colorCanvas');
    const aOverlay = document.getElementById('aOverlay');
    const ctx = colorCanvas.getContext('2d');
    const aCtx = aOverlay.getContext('2d');
    const backgroundImage = new Image();
    let audioInitialized = false;
    let isTouchDevice = false;
    let isAMode = false;
    let aImage = null;
    let selectedLetter = 'A';
    let selectedButton = null;

    // Detect touch device
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      isTouchDevice = true;
    }

    // Create letter grid
    function createLetterGrid() {
      const letterGrid = document.getElementById('letterGrid');
      const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
      const numbers = '0123456789';
      
      // Clear existing content except close button
      const closeBtn = document.getElementById('closeLetterGrid');
      letterGrid.innerHTML = '';
      letterGrid.appendChild(closeBtn);
      
      // Add letters
      for (let i = 0; i < letters.length; i++) {
        const letter = letters[i];
        const letterItem = document.createElement('button');
        letterItem.className = 'letter-item';
        letterItem.textContent = letter + letter.toLowerCase();
        letterItem.addEventListener('click', () => showStencilOverlay(letter + letter.toLowerCase()));
        letterGrid.appendChild(letterItem);
      }
      // Add numbers
      for (let i = 0; i < numbers.length; i++) {
        const number = numbers[i];
        const numberItem = document.createElement('button');
        numberItem.className = 'letter-item';
        numberItem.textContent = number;
        numberItem.addEventListener('click', () => showStencilOverlay(number));
        letterGrid.appendChild(numberItem);
      }
    }

    function selectLetter(letter) {
      selectedLetter = letter;
      document.getElementById('letterGridModal').style.display = 'none';
      createAImage().then(img => {
        aImage = img;
        if (isAMode) {
          drawAOverlay();
        }
      });
    }

    // Create A image from the selected letter
    function createAImage() {
      return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas size
        canvas.width = 1000;
        canvas.height = 1000;
        
        // Fill with transparent
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Create the selected letter/number
        ctx.fillStyle = 'white';
        ctx.font = 'bold 600px "Comic Sans MS", "Comic Sans", cursive, sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(selectedLetter, canvas.width/2, canvas.height/2);
        
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = canvas.toDataURL();
      });
    }

    // Initialize letter grid and A image
    createLetterGrid();
    createAImage().then(img => {
      aImage = img;
    });

    // Create a fallback white background
    function createWhiteBackground() {
      ctx.fillStyle = 'white';
      ctx.fillRect(0, 0, colorCanvas.width, colorCanvas.height);
    }

    backgroundImage.src = 'white-wall.jpg';
    backgroundImage.onerror = function() {
      createWhiteBackground();
    };

    backgroundImage.onload = function() {
      ctx.drawImage(backgroundImage, 0, 0, colorCanvas.width, colorCanvas.height);
    };

    function resizeCanvasDimensions() {
      colorCanvas.width = aOverlay.width = window.innerWidth;
      colorCanvas.height = aOverlay.height = window.innerHeight;
      
      if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        ctx.drawImage(backgroundImage, 0, 0, colorCanvas.width, colorCanvas.height);
      } else {
        createWhiteBackground();
      }
      
      // Redraw A overlay if in A mode
      if (isAMode && aImage) {
        drawAOverlay();
      }
    }

    function drawAOverlay() {
      aCtx.clearRect(0, 0, aOverlay.width, aOverlay.height);
      
      // Fill entire canvas with black
      aCtx.fillStyle = 'black';
      aCtx.fillRect(0, 0, aOverlay.width, aOverlay.height);
      
      // Calculate scaling to fit image in canvas while maintaining aspect ratio
      const scale = Math.min(aOverlay.width / aImage.width, aOverlay.height / aImage.height) * 0.8;
      const scaledWidth = aImage.width * scale;
      const scaledHeight = aImage.height * scale;
      const x = (aOverlay.width - scaledWidth) / 2;
      const y = (aOverlay.height - scaledHeight) / 2;
      
      // Use destination-out to create transparent areas where the letter image is
      aCtx.globalCompositeOperation = 'destination-out';
      aCtx.drawImage(aImage, x, y, scaledWidth, scaledHeight);
      aCtx.globalCompositeOperation = 'source-over';
    }

    function setSelectedButton(button) {
      // Remove selection from previous button
      if (selectedButton) {
        selectedButton.classList.remove('selected');
      }
      
      // Add selection to new button
      if (button) {
        button.classList.add('selected');
        selectedButton = button;
      }
    }

    function setAMode() {
      initAudio();
      isAMode = true;
      isGradientMode = false;
      isEraserMode = false;
      aOverlay.style.display = 'block';
      document.getElementById('aCancelBtn').style.display = 'flex';
      setSelectedButton(document.getElementById('aBtn'));
      if (aImage) {
        drawAOverlay();
      }
      console.log('A mode activated with letter:', selectedLetter);
    }

    function exitAMode() {
      isAMode = false;
      aOverlay.style.display = 'none';
      document.getElementById('aCancelBtn').style.display = 'none';
      if (selectedButton === document.getElementById('aBtn')) {
        setSelectedButton(null);
      }
    }

    resizeCanvasDimensions();
    window.addEventListener('resize', resizeCanvasDimensions);

    let painting = false;
    let currentColor = 'rgb(255, 0, 221)';
    let isGradientMode = false;
    let isEraserMode = false;
    let gradientColors = [];
    let gradientIndex = 0;
    let colorTimer = 0;
    let colorDuration = 500;
    let lastColorChangeTime = 0;
    let currentGradientColor = null;
    let nextGradientColor = null;
    let colorTransitionProgress = 0;
    let brushSize = 30;
    let eraserAudioTimer = 0;
    let lastPlayedNote = null;
    let noteChangeThreshold = 80;
    let eraserMoving = false;
    let eraserPath = [];

    let synth;
    let currentNote = null;
    let noteScheduler = null;
    let playingNotes = new Set();

    const colorNotes = {
      pink: "C4",
      purple: "D4",
      yellow: "E4",
      orange: "F4",
      blue: "G4"
    };

    const colors = [
      { name: 'pink', rgb: 'rgb(255, 0, 221)', r: 255, g: 0, b: 221 },
      { name: 'purple', rgb: 'rgb(92, 0, 157)', r: 92, g: 0, b: 157 },
      { name: 'yellow', rgb: 'rgb(255, 187, 0)', r: 255, g: 187, b: 0 },
      { name: 'orange', rgb: 'rgb(255, 77, 0)', r: 255, g: 77, b: 0 },
      { name: 'blue', rgb: 'rgb(125, 244, 255)', r: 125, g: 244, b: 255 }
    ];

    // Initialize audio context on first user interaction
    async function initAudio() {
      if (!audioInitialized) {
        try {
          await Tone.start();
          synth = new Tone.AMSynth().toDestination();
          audioInitialized = true;
          console.log('Audio initialized successfully');
        } catch (error) {
          console.log('Audio initialization failed:', error);
        }
      }
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function setColor(color, button) {
      initAudio();
      currentColor = color;
      isGradientMode = false;
      isEraserMode = false;
      setSelectedButton(button);
      console.log('Color set to:', color);
    }

    function setGradientMode(button) {
      initAudio();
      isGradientMode = true;
      isEraserMode = false;
      setSelectedButton(button);
      gradientColors = shuffleArray(colors);
      gradientIndex = 0;
      colorTimer = 0;
      lastColorChangeTime = Date.now();
      currentGradientColor = gradientColors[0];
      nextGradientColor = gradientColors[1];
      colorTransitionProgress = 0;
      console.log('Gradient mode activated with colors:', gradientColors);
    }

    function setEraserMode(button) {
      initAudio();
      isEraserMode = true;
      isGradientMode = false;
      setSelectedButton(button);
      console.log('Eraser mode activated');
    }

    function resetCanvas() {
      ctx.clearRect(0, 0, colorCanvas.width, colorCanvas.height);
      if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        ctx.drawImage(backgroundImage, 0, 0, colorCanvas.width, colorCanvas.height);
      } else {
        createWhiteBackground();
      }
      
      if (isAMode) {
        exitAMode();
      }
    }

    function captureCanvas() {
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      
      tempCanvas.width = colorCanvas.width;
      tempCanvas.height = colorCanvas.height;
      
      // Always draw the background first
      if (backgroundImage.complete && backgroundImage.naturalWidth > 0) {
        tempCtx.drawImage(backgroundImage, 0, 0, tempCanvas.width, tempCanvas.height);
      } else {
        tempCtx.fillStyle = 'white';
        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
      }
      // Draw only the colored strokes (transparent where erased)
      tempCtx.drawImage(colorCanvas, 0, 0);
      // Overlay stencil/A mode if active
      if ((isAMode || isStencilMode) && aOverlay.style.display !== 'none') {
        tempCtx.drawImage(aOverlay, 0, 0);
      }
      
      tempCanvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        
        const now = new Date();
        const timestamp = now.getFullYear() + 
          String(now.getMonth() + 1).padStart(2, '0') + 
          String(now.getDate()).padStart(2, '0') + '_' +
          String(now.getHours()).padStart(2, '0') + 
          String(now.getMinutes()).padStart(2, '0') + 
          String(now.getSeconds()).padStart(2, '0');
        
        link.download = `drawing_${timestamp}.png`;
        
        if (navigator.userAgent.match(/iPhone|iPad/)) {
          const newWindow = window.open();
          newWindow.document.write(`
            <img src="${url}" style="max-width:100%; height:auto;">
            <p>Tap and hold the image above, then select "Save to Photos" or "Save Image"</p>
          `);
          newWindow.document.title = `drawing_${timestamp}.png`;
        } else {
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
        }
        
        setTimeout(() => URL.revokeObjectURL(url), 100);
      }, 'image/png', 1.0);
    }

    function getColorAtPixel(x, y) {
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      const r = pixel[0], g = pixel[1], b = pixel[2], a = pixel[3];
      
      if (a === 0) return null;
      
      // Don't erase white background - check if it's close to white
      if (r > 240 && g > 240 && b > 240) return null;
      
      if (r === 255 && g === 0 && b === 221) return 'pink';
      if (r === 92 && g === 0 && b === 157) return 'purple';
      if (r === 255 && g === 187 && b === 0) return 'yellow';
      if (r === 255 && g === 77 && b === 0) return 'orange';
      if (r === 125 && g === 244 && b === 255) return 'blue';
      
      let closestColor = null;
      let minDistance = Infinity;
      
      for (const color of colors) {
        const distance = Math.sqrt(
          Math.pow(r - color.r, 2) + 
          Math.pow(g - color.g, 2) + 
          Math.pow(b - color.b, 2)
        );
        if (distance < minDistance) {
          minDistance = distance;
          closestColor = color.name;
        }
      }
      
      return minDistance < 100 ? closestColor : null;
    }

    async function playNote(colorName) {
      const note = colorNotes[colorName];
      if (note && audioInitialized && synth) {
        try {
          if (isGradientMode) {
            synth.triggerAttackRelease(note, "4n");
          } else {
            synth.triggerAttackRelease(note, "8n");
          }
        } catch (error) {
          console.log('Audio playback error:', error);
        }
      }
    }

    function interpolateColor(color1, color2, progress) {
      const r = Math.round(color1.r + (color2.r - color1.r) * progress);
      const g = Math.round(color1.g + (color2.g - color1.g) * progress);
      const b = Math.round(color1.b + (color2.b - color1.b) * progress);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function updateGradientColor() {
      if (!isGradientMode) return currentColor;

      const now = Date.now();
      const elapsed = now - lastColorChangeTime;
      
      colorTransitionProgress = Math.min(elapsed / colorDuration, 1);
      
      if (colorTransitionProgress >= 1) {
        gradientIndex = (gradientIndex + 1) % gradientColors.length;
        currentGradientColor = gradientColors[gradientIndex];
        nextGradientColor = gradientColors[(gradientIndex + 1) % gradientColors.length];
        lastColorChangeTime = now;
        colorTransitionProgress = 0;
        
        playNote(currentGradientColor.name);
      }
      
      return interpolateColor(currentGradientColor, nextGradientColor, colorTransitionProgress);
    }

    function getColorNameFromRGB(rgbString) {
      const match = rgbString.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (!match) return null;
      
      const r = parseInt(match[1]);
      const g = parseInt(match[2]);
      const b = parseInt(match[3]);
      
      let closestColor = null;
      let minDistance = Infinity;
      
      for (const color of colors) {
        const distance = Math.sqrt(
          Math.pow(r - color.r, 2) + 
          Math.pow(g - color.g, 2) + 
          Math.pow(b - color.b, 2)
        );
        if (distance < minDistance) {
          minDistance = distance;
          closestColor = color.name;
        }
      }
      
      return closestColor;
    }

    function getRandomColorForEraser() {
      const randomIndex = Math.floor(Math.random() * colors.length);
      return colors[randomIndex].name;
    }

    function shouldPlayEraserAudio() {
      const now = Date.now();
      if (now - eraserAudioTimer > 60) {
        eraserAudioTimer = now;
        return true;
      }
      return false;
    }

    function playNoteIfDifferent(colorName, forcePlay = false) {
      const now = Date.now();
      if (colorName && (forcePlay || colorName !== lastPlayedNote || now - eraserAudioTimer > noteChangeThreshold)) {
        playNote(colorName);
        lastPlayedNote = colorName;
        return true;
      }
      return false;
    }

    function getDetailedColorSample(x, y, radius = 8) {
      const samples = [];
      const step = 2;
      
      for (let angle = 0; angle < 360; angle += 45) {
        const rad = (angle * Math.PI) / 180;
        const px = Math.round(x + Math.cos(rad) * radius);
        const py = Math.round(y + Math.sin(rad) * radius);
        
        if (px >= 0 && py >= 0 && px < colorCanvas.width && py < colorCanvas.height) {
          const color = getColorAtPixel(px, py);
          if (color) samples.push(color);
        }
      }
      
      const centerSamples = [
        [x, y], [x-1, y], [x+1, y], [x, y-1], [x, y+1]
      ];
      
      for (const [px, py] of centerSamples) {
        if (px >= 0 && py >= 0 && px < colorCanvas.width && py < colorCanvas.height) {
          const color = getColorAtPixel(px, py);
          if (color) samples.push(color);
        }
      }
      
      if (samples.length === 0) return null;
      
      const colorCounts = {};
      samples.forEach(color => {
        colorCounts[color] = (colorCounts[color] || 0) + 1;
      });
      
      return Object.keys(colorCounts).reduce((a, b) => 
        colorCounts[a] > colorCounts[b] ? a : b
      );
    }

    function maintainEraserAudio() {
      if (isEraserMode && painting && eraserMoving) {
        const lastPoint = eraserPath[eraserPath.length - 1];
        if (lastPoint) {
          const colorName = getDetailedColorSample(lastPoint.x, lastPoint.y);
          if (colorName) {
            const now = Date.now();
            if (now - eraserAudioTimer > 80 || colorName !== lastPlayedNote) {
              playNoteIfDifferent(colorName);
              eraserAudioTimer = now;
            }
          }
        }
      }
    }

    function draw(x, y) {
      if (!painting) return;
      // If stencil mode is active, only allow drawing inside the transparent area
      if (isStencilMode) {
        // Check if pixel is inside the letter/digit area by sampling overlay alpha
        const overlayPixel = aCtx.getImageData(x, y, 1, 1).data;
        // If overlay is transparent (alpha == 0), allow drawing
        if (overlayPixel[3] === 0) {
          if (isEraserMode) {
            eraserPath.push({x, y, timestamp: Date.now()});
            if (eraserPath.length > 10) {
              eraserPath.shift();
            }
            eraserMoving = true;
            const colorName = getDetailedColorSample(x, y, brushSize / 3);
            if (colorName) {
              const now = Date.now();
              const timeSinceLastNote = now - eraserAudioTimer;
              if (colorName !== lastPlayedNote || timeSinceLastNote > 60) {
                playNoteIfDifferent(colorName, timeSinceLastNote > 120);
              }
            }
            const imageData = ctx.getImageData(x - brushSize/2, y - brushSize/2, brushSize, brushSize);
            const data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              if (!(r > 240 && g > 240 && b > 240)) {
                const pixelIndex = i / 4;
                const pixelX = (pixelIndex % brushSize) - brushSize/2;
                const pixelY = Math.floor(pixelIndex / brushSize) - brushSize/2;
                const distance = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
                if (distance <= brushSize/2) {
                  data[i + 3] = 0;
                }
              }
            }
            ctx.putImageData(imageData, x - brushSize/2, y - brushSize/2);
          } else if (isGradientMode) {
            const gradientColor = updateGradientColor();
            ctx.lineTo(x, y);
            ctx.strokeStyle = gradientColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = "round";
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
            ctx.strokeStyle = currentColor;
            ctx.lineWidth = brushSize;
            ctx.lineCap = "round";
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
            const colorName = getColorNameFromRGB(currentColor);
            if (colorName) playNote(colorName);
          }
        }
        // If not in transparent area, do nothing
        return;
      }
      // ...existing code for normal draw...
      if (isEraserMode) {
        eraserPath.push({x, y, timestamp: Date.now()});
        if (eraserPath.length > 10) {
          eraserPath.shift();
        }
        eraserMoving = true;
        const colorName = getDetailedColorSample(x, y, brushSize / 3);
        if (colorName) {
          const now = Date.now();
          const timeSinceLastNote = now - eraserAudioTimer;
          if (colorName !== lastPlayedNote || timeSinceLastNote > 60) {
            playNoteIfDifferent(colorName, timeSinceLastNote > 120);
          }
        }
        const imageData = ctx.getImageData(x - brushSize/2, y - brushSize/2, brushSize, brushSize);
        const data = imageData.data;
        for (let i = 0; i < data.length; i += 4) {
          const r = data[i];
          const g = data[i + 1];
          const b = data[i + 2];
          const a = data[i + 3];
          // Only erase colored brush strokes, not white or background
          // If pixel is close to white, skip
          if (!(r > 240 && g > 240 && b > 240)) {
            // If pixel is not white and not fully background, erase it
            // This will erase gradients and blends too
            const pixelIndex = i / 4;
            const pixelX = (pixelIndex % brushSize) - brushSize/2;
            const pixelY = Math.floor(pixelIndex / brushSize) - brushSize/2;
            const distance = Math.sqrt(pixelX * pixelX + pixelY * pixelY);
            if (distance <= brushSize/2) {
              data[i + 3] = 0;
            }
          }
        }
        ctx.putImageData(imageData, x - brushSize/2, y - brushSize/2);
      } else if (isGradientMode) {
        const gradientColor = updateGradientColor();
        ctx.lineTo(x, y);
        ctx.strokeStyle = gradientColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = "round";
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
        ctx.strokeStyle = currentColor;
        ctx.lineWidth = brushSize;
        ctx.lineCap = "round";
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y);
        const colorName = getColorNameFromRGB(currentColor);
        if (colorName) playNote(colorName);
      }
    }

    function getEventCoords(e) {
      const rect = colorCanvas.getBoundingClientRect();
      let x, y;
      
      if (e.touches && e.touches.length > 0) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      
      x = x * (colorCanvas.width / rect.width);
      y = y * (colorCanvas.height / rect.height);
      
      return { x, y };
    }

    function startDraw(e) {
      e.preventDefault();
      initAudio();
      painting = true;
      
      lastPlayedNote = null;
      eraserAudioTimer = 0;
      eraserMoving = false;
      eraserPath = [];
      
      const coords = getEventCoords(e);
      ctx.beginPath();
      ctx.moveTo(coords.x, coords.y);
      
      if (isGradientMode) {
        gradientColors = shuffleArray(colors);
        gradientIndex = 0;
        lastColorChangeTime = Date.now();
        currentGradientColor = gradientColors[0];
        nextGradientColor = gradientColors[1];
        colorTransitionProgress = 0;
        if (audioInitialized && synth) {
          try {
            synth.triggerAttackRelease(colorNotes[currentGradientColor.name], "2n");
          } catch (error) {
            console.log('Audio playback error:', error);
          }
        }
      }
      
      draw(coords.x, coords.y);
    }

    function endDraw(e) {
      e.preventDefault();
      painting = false;
      eraserMoving = false;
      eraserPath = [];
      ctx.beginPath();
    }

    function moveDraw(e) {
      e.preventDefault();
      if (!painting) return;
      const coords = getEventCoords(e);
      draw(coords.x, coords.y);
    }

    // Dropdown functionality
    const dropdownToggle = document.getElementById('dropdownToggle');
    const dropdownMenu = document.getElementById('dropdownMenu');
    let isDropdownOpen = false;

    function toggleDropdown() {
      isDropdownOpen = !isDropdownOpen;
      if (isDropdownOpen) {
        dropdownMenu.classList.add('open');
        dropdownToggle.textContent = 'âœ•';
        dropdownToggle.classList.add('selected');
      } else {
        dropdownMenu.classList.remove('open');
        dropdownToggle.textContent = 'â˜°';
        dropdownToggle.classList.remove('selected');
      }
    }

    dropdownToggle.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      toggleDropdown();
    });

    dropdownToggle.addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      toggleDropdown();
    });

    // Color button event listeners
    document.querySelectorAll('.dropdown-item[data-color]').forEach(button => {
      button.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const color = this.getAttribute('data-color');
        setColor(color, this);
      });
      
      button.addEventListener('touchend', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const color = this.getAttribute('data-color');
        setColor(color, this);
      });
    });

    // Gradient button
    document.getElementById('gradientBtn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      setGradientMode(this);
    });

    document.getElementById('gradientBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      setGradientMode(this);
    });

    // Eraser button
    document.getElementById('eraserBtn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      setEraserMode(this);
    });

    document.getElementById('eraserBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      setEraserMode(this);
    });

    // A/a button
    document.getElementById('aBtn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      document.getElementById('letterGridModal').style.display = 'flex';
    });

    document.getElementById('aBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      document.getElementById('letterGridModal').style.display = 'flex';
    });

    // Close letter grid
    document.getElementById('closeLetterGrid').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      document.getElementById('letterGridModal').style.display = 'none';
    });

    // A Cancel button
    document.getElementById('aCancelBtn').addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      exitAMode();
    });

    document.getElementById('aCancelBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      e.stopPropagation();
      exitAMode();
    });

    // Brush size slider
    const brushSizeSlider = document.getElementById('brushSizeSlider');
    const brushSizeLabel = document.getElementById('brushSizeLabel');
    
    brushSizeSlider.addEventListener('input', function(e) {
      e.stopPropagation();
      brushSize = parseInt(e.target.value);
      brushSizeLabel.textContent = brushSize + 'px';
    });

    brushSizeSlider.addEventListener('change', function(e) {
      e.stopPropagation();
      brushSize = parseInt(e.target.value);
      brushSizeLabel.textContent = brushSize + 'px';
    });

    // Reset button
    document.getElementById('mainResetBtn').addEventListener('click', function(e) {
      e.preventDefault();
      resetCanvas();
    });

    document.getElementById('mainResetBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      resetCanvas();
    });

    // Camera button
    document.getElementById('cameraBtn').addEventListener('click', function(e) {
      e.preventDefault();
      captureCanvas();
    });

    document.getElementById('cameraBtn').addEventListener('touchend', function(e) {
      e.preventDefault();
      captureCanvas();
    });

    // Canvas drawing events
    if (isTouchDevice) {
      colorCanvas.addEventListener('touchstart', startDraw, { passive: false });
      colorCanvas.addEventListener('touchend', endDraw, { passive: false });
      colorCanvas.addEventListener('touchmove', moveDraw, { passive: false });
    } else {
      colorCanvas.addEventListener('mousedown', startDraw);
      colorCanvas.addEventListener('mouseup', endDraw);
      colorCanvas.addEventListener('mousemove', moveDraw);
    }

    // Ensure audio context is started on any user interaction
    document.addEventListener('touchstart', initAudio, { once: true });
    document.addEventListener('click', initAudio, { once: true });

    // Continuous audio maintenance for eraser
    setInterval(maintainEraserAudio, 50);

    // Set initial color selection
    setColor('rgb(255, 0, 221)', document.querySelector('.dropdown-item.pink'));
  </script>
</body>
</html>